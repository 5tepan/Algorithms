{
1. 17.3. ????????? (8)
??????????? ???????? ?????, ??????? ????????? ???????? ????? ??????? ? ?????? ??????. ????????? ?? ????????? ????? ????? ??????????? ????? ??????? ???????? ????, ??????????? ??? ????? ? ?????????. 
2.Фомин Степан ПС-21
3. Dev+GNU Pascal 1.9.4.13
   Кодировка - 1251
4.INPUT - input.txt
  OUTPUT - output.txt
5.INPUT - ???? ?? ????? INPUT.TXT. ? ?????? ?????? ?????? ????? ????? N (1 =  N =  106). ?? ?????? ?????? ?????? ????? ?? N ????????? ????????? ????. i-?? ???????? ????????? ????????? j-?. ?????? 'N' ????????, ??? i-? ??????? ?? ??????? ?? j-?? ????????.
  OUTPUT - ????? ? ???? OUTPUT.TXT. ? ???????????? ?????? ?????? ???? ??????????? ????? ???????????? ???????? ????????, ??????????? ??? ????????? ??????????. ???? ??? ??????????, ??????? -1.
}




PROGRAM palindrom;
CONST 
  MaxKol=1000000;
Type
  ArrayStr= array [65..90] of LongInt;//количество каждой буквы  c A(65)  по Z(90)
  ArrayData= array [1..MaxKol,0..1] of INTEGER; // буква, использование
  FTreeArray= array [0..MaxKol] of LongInt;// дерево Фенвика
Var
  Fin,Fout: Text;
  NameFile: STRING;
  Ch: CHAR;
  i, j, Kol, KolStep: LongInt;
  StrAlphabet: ArrayStr;
  StrData: ArrayData;
  FTree: FTreeArray;

// Фенвик
PROCEDURE PrintF();                                                
VAR
  i,j: LongInt;
BEGIN
  FOR i:=0 TO Kol
  DO    
    WRITE(FOUT," ",FTree[i]);
 WRITELN(FOUT);
END;

FUNCTION Rsq(k: LongInt): LongInt;
VAR
  res : LongInt;
BEGIN
  res:=0;
  WHILE (k >= 0)
  DO
    BEGIN
      INC(res, FTree[k]);
      k := k and (k + 1) - 1;
    END;
  Rsq:=res;
END;

PROCEDURE Add(k, d: LongInt);
BEGIN
  WHILE (k < Kol)
  DO
    BEGIN
      INC(FTree[k],D);
      k := k or (k + 1);
    END;
END;

// палиндром
PROCEDURE Print();                                                
VAR
  i,j: LongInt;
BEGIN
  FOR i:=1 TO Kol
  DO    
    WRITE(FOUT," ",StrData[i,1]);
  WRITELN(FOUT);                

END;

FUNCTION IsNotPalindrom(): BOOLEAN;
VAR
  i,j: LongInt;
BEGIN
  j:=0;
  FOR i:=65 TO 90
  DO
    IF  (StrAlphabet[i] MOD 2)<>0
    THEN
      INC(j);                      
  IF (j+(Kol MOD 2)=0) OR ((j=1) AND ((Kol MOD 2)=1)) // одна буква нечетная и длина строки нечетная или все четное
  THEN
    IsNotPalindrom:= FALSE
  ELSE  
    IsNotPalindrom:= TRUE;
END;

PROCEDURE Find(Poz:LongInt);                                                
VAR
 StepB,StepE,i,ii: LongInt;
BEGIN
  ii:=StrData[Poz,0];
  
  StepE:=0;
  IF  StrAlphabet[ii]=1 //центр
  THEN
    INC(KolStep,(Rsq(Kol-1)-Rsq(ii))DIV 2)
  ELSE
    BEGIN
      FOR i:=Kol DOWNTO Poz+1   //ищем нужную букву с конца
      DO
        IF  (StrData[i,0]=StrData[Poz,0]) AND (StrData[i,1]>0)
        THEN
          BEGIN
            StepE:=i;         
            BREAK;
          END;   
        // добавляе шаги             
        INC(KolStep,Rsq(Kol-1)-Rsq(StepE-1));
    END;        
    
  // обнуляем использование начала
  StrData[Poz,1]:=0;
  Add(Poz-1,-1);          
  
  // обнуляем использование окончания  
  IF  StepE>1 
  THEN
    BEGIN
      StrData[StepE,1]:=0;  
      Add(StepE-1,-1);      
      INC(StrAlphabet[ii],-1);      
    END;   
  
    INC(StrAlphabet[ii],-1);      
END;

BEGIN
  ASSIGN(Fin, 'input.txt');
  RESET(Fin);
  ASSIGN(FOut, 'output.txt');
  REWRITE(FOut);
  Kol:=0;
  WHILE (NOT EOF(Fin)) AND (Kol<=1000000)
  DO  
    BEGIN
      IF EOLN(Fin)
      THEN
        READLN(Fin,Ch)
      ELSE
        READ(Fin,Ch);
      IF  (ORD(Ch)>=65) AND (ORD(Ch)<=90)
      THEN
        BEGIN
          INC(Kol);           
          INC(StrAlphabet[ORD(Ch)]);  
          StrData[Kol,0]:=ORD(Ch);
          StrData[Kol,1]:=1;
        END;
    END;

  IF (Kol=0) OR IsNotPalindrom()
  THEN
    BEGIN
      WRITELN(FOUT,-1);    
      EXIT;
    END;

  //строим Фенвика   
  FOR i:=0 TO Kol-1
  DO
    Add(i,1);          
  KolStep:=0;    
  FOR i:=1 TO Kol-1
  DO
  BEGIN
    IF (StrData[i,1]>0)
    THEN
      BEGIN
        Find(i);  
      END;
    END;
  WRITELN(FOUT,KolStep);
END.  


